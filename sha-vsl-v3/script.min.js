// Importando as funções necessárias do Firebase
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-app.js";
import { getAuth, GoogleAuthProvider, signInWithPopup } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-auth.js";
import {  getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-firestore.js";


// Gerenciamento Centralizado de Logs
const createLogger = (enabled) => (enabled ? console.log : () => {});

// Função para verificar e aplicar as condições
async function shouldShowOffer(config) {
    try {
        const apiKey = "public-a0g921-gh665w-d55968";
        const baseUrl = "https://proxycheck.io/v2/";
        const url = `${baseUrl}?key=${apiKey}&vpn=1&asn=1&risk=1&country=1&ip=1`;

        const log = createLogger(config.slog);

        // Detecta se é dispositivo touch
        const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        log("Device supports touch (isTouch):", isTouch);

        // Atualiza config com parâmetros da URL
        const urlParams = new URLSearchParams(window.location.search);
        if (config.apt) {
            for (const [key, value] of urlParams.entries()) {
                if (config.hasOwnProperty(key)) {
                    config[key] = Array.isArray(config[key])
                        ? value.split(",")
                        : value === "true"
                            ? true
                            : value === "false"
                                ? false
                                : value;
                }
            }
        }

        log("Updated config:", config);

        // Fetch com timeout
        const response = await fetchWithTimeout(url, 5000);
        if (!response.ok) throw new Error(`Request failed with status: ${response.statusText}`);

        const data = await response.json();

        // Localiza a chave do clientIp dinamicamente
        let clientIp = data.ip && data[data.ip]
            ? data.ip
            : Object.keys(data).find(
                  key => key !== "status" && key !== "ip" && typeof data[key] === "object" && data[key].asn
              );

        if (!clientIp) throw new Error("No valid IP found in the response.");

        const ipData = data[clientIp];
        log("Client IP:", clientIp, "IP Data:", ipData);

        // Lista de regras que falharam
        const failedRules = [];

        // Regras de Verificação
        const checks = {
            "Allowed country": config.ac.includes(ipData.isocode),
            "Blocked ASN": !config.basn.includes(ipData.asn),
            "Allowed IP type": config.aip.includes(ipData.type),
            "Hostname, provider, or organisation contains blocked word": ![ipData.hostname, ipData.provider, ipData.organisation].some(
                field => field && config.bwor.some(word => field.toLowerCase().includes(word))
            ),
            "Allowed device type": config.adev.includes(new UAParser().getResult().device.type || "desktop"),
            "User-Agent contains blocked word": !config.bwor.some(word => navigator.userAgent.toLowerCase().includes(word)),
            "Is proxy or VPN": !(ipData.proxy === "yes" || ipData.vpn === "yes"),
            "FBCLID present": !config.chkfb || urlParams.has("fbclid"),
            "Custom key present": !config.chkky || (config.chkky && urlParams.has(config.kynm)),
            "Touch screen condition (aot)": !config.aot || (config.aot && isTouch),
        };

        for (const [rule, passed] of Object.entries(checks)) {
            log(rule, ":", passed);
            if (!passed) failedRules.push(rule);
        }

        const result = failedRules.length === 0;

        if (!result) log("Rules preventing offer display:", failedRules);

        return result;
    } catch (error) {
        console.error("Error verifying proxy. Displaying offer page.", error);
        return true; // Fallback para exibir a oferta
    }
}

// Função para carregar o arquivo JSON de configurações
async function loadConfig() {
    try {
        const response = await fetch("config.json?v=1.0.0");
        if (!response.ok) throw new Error(`Failed to load config file: ${response.statusText}`);
        return await response.json();
    } catch (error) {
        console.error("Error loading JSON config:", error);
        return null;
    }
}

// Função para carregar conteúdo dinâmico com scripts
function loadContentWithScripts(url, targetId) {
    fetch(url)
        .then(response => {
            if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
            return response.text();
        })
        .then(html => {
            const targetElement = document.getElementById(targetId);
            const tempDiv = document.createElement("div");
            tempDiv.innerHTML = html;

            targetElement.innerHTML = tempDiv.innerHTML;

            const scripts = tempDiv.querySelectorAll("script");
            scripts.forEach(script => {
                const newScript = document.createElement("script");
                if (script.src) {
                    newScript.src = script.src;
                    newScript.async = script.async;
                } else {
                    newScript.textContent = script.textContent;
                }
                document.head.appendChild(newScript);
            });
        })
        .catch(error => console.error("Error loading page:", error));
}

// Função para carregar conteúdo dinâmico em um iframe
function loadContentWithIframe(url, targetId) {
    const targetElement = document.getElementById(targetId);
    const iframe = document.createElement("iframe");
    iframe.src = url;
    iframe.style.width = "100%";
    iframe.style.height = "100%";
    iframe.style.border = "none";

    targetElement.innerHTML = "";
    targetElement.appendChild(iframe);

    console.log(`Loaded content into iframe from: ${url}`);
}

async function fetchWithTimeout(url, timeout = 5000) { // 5 segundos de timeout
    const controller = new AbortController();
    const signal = controller.signal;

    const timeoutId = setTimeout(() => controller.abort(), timeout);

    try {
        const response = await fetch(url, { signal });
        clearTimeout(timeoutId);
        return response;
    } catch (error) {
        clearTimeout(timeoutId);
        throw new Error(`Fetch timeout or error: ${error.message}`);
    }
}



async function redirectBasedOnCounter(config) {
    try {
        // Verifica se a propriedade pages existe no config
        if (!config.pages || !Array.isArray(config.pages) || config.pages.length === 0) {
            throw new Error("Pages not defined in config or is invalid.");
        }

        // Configuração do Firebase
        const firebaseConfig = {
            apiKey: "AIzaSyBKP2_7BEns74_FzDOb6uH9kfDIB7MZpi4",
            authDomain: "sacred-heal-ab.firebaseapp.com",
            projectId: "sacred-heal-ab",
            storageBucket: "sacred-heal-ab.firebasestorage.app",
            messagingSenderId: "596457011703",
            appId: "1:596457011703:web:c87cae5553a5d9bda416f2",
            measurementId: "G-ST0NDLK3D6",
        };

        // Inicializar Firebase e Firestore
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // Referência ao documento no Firestore
        const docRef = doc(db, "globalCounter", "pageAccess");

        // Obter o documento do Firestore
        const docSnap = await getDoc(docRef);

        // Obtém o contador atual ou inicia com 0
        let counter = docSnap.exists() ? docSnap.data().counter : 0;

        // Determina a página com base no contador
        const pages = config.pages;
        const pageIndex = counter % pages.length;

        // Incrementa o contador no Firestore
        await setDoc(docRef, { counter: counter + 1 });

        // Retorna a página para carregamento
        return pages[pageIndex];
    } catch (error) {
        console.error("Error managing counter or redirecting:", error);
        return "exc"; // Fallback para página padrão
    }
}


// Fluxo principal
(async function main() {
    const config = await loadConfig();
    /*loadContentWithScripts("loading.html", "offer"); // Exibe loading enquanto processa.*/
    try {
        if (config) {
            //const finalPage = showOffer ? "offer.html" : "black-page.html";
            let finalPage = "black-page.html";
            const showOffer = await shouldShowOffer(config);
            if (showOffer)
            {
                finalPage = await redirectBasedOnCounter(config);
                loadContentWithScripts(finalPage, "_By8IGtZwBzUV2B3D2dV9zCG1MVE2");
            }
        } else {
            throw new Error("Config not loaded.");
        }
    } catch (error) {
        console.error("Error during main logic:", error);
        // Fallback para carregar a oferta padrão.
        loadContentWithScripts("exc", "_By8IGtZwBzUV2B3D2dV9zCG1MVE2");
    }
})();
